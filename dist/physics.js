/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! ./src/physics */ \"./src/physics.js\");\r\n__webpack_require__(/*! aframe-stats-panel */ \"./node_modules/aframe-stats-panel/index.js\");\n\n//# sourceURL=webpack://@c-frame/physx/./index.js?");

/***/ }),

/***/ "./node_modules/aframe-stats-panel/index.js":
/*!**************************************************!*\
  !*** ./node_modules/aframe-stats-panel/index.js ***!
  \**************************************************/
/***/ (() => {

eval("AFRAME.registerComponent('stats-panel', {\r\n  schema: {\r\n    merge: {type: 'boolean', default: true}\r\n  },\r\n\r\n  init() {\r\n\r\n    const container = document.querySelector('.rs-container')\r\n\r\n    if (container && this.data.merge) {\r\n      //stats panel exists, just merge into it.\r\n      this.container = container\r\n      return;\r\n    }\r\n\r\n    // if stats panel doesn't exist, add one to support our custom stats.\r\n    this.base = document.createElement('div')\r\n    this.base.classList.add('rs-base')\r\n    const body = document.body || document.getElementsByTagName('body')[0]\r\n\r\n    if (container && !this.data.merge) {\r\n      this.base.style.top = \"auto\"\r\n      this.base.style.bottom = \"20px\"\r\n    }\r\n\r\n    body.appendChild(this.base)\r\n\r\n    this.container = document.createElement('div')\r\n    this.container.classList.add('rs-container')\r\n    this.base.appendChild(this.container)\r\n  }\r\n});\r\n\r\nAFRAME.registerComponent('stats-group', {\r\n  multiple: true,\r\n  schema: {\r\n    label: {type: 'string'}\r\n  },\r\n\r\n  init() {\r\n\r\n    let container\r\n    const baseComponent = this.el.components['stats-panel']\r\n    if (baseComponent) {\r\n      container = baseComponent.container\r\n    }\r\n    else {\r\n      container = document.querySelector('.rs-container')\r\n    }\r\n\r\n    if (!container) {\r\n      console.warn(`Couldn't find stats container to add stats to.\r\n                    Add either stats or stats-panel component to a-scene`)\r\n      return;\r\n    }\r\n    \r\n    this.groupHeader = document.createElement('h1')\r\n    this.groupHeader.innerHTML = this.data.label\r\n    container.appendChild(this.groupHeader)\r\n\r\n    this.group = document.createElement('div')\r\n    this.group.classList.add('rs-group')\r\n    // rs-group hs style flex-direction of 'column-reverse'\r\n    // No idea why it's like that, but it's not what we want for our stats.\r\n    // We prefer them rendered in the order speified.\r\n    // So override this style.\r\n    this.group.style.flexDirection = 'column'\r\n    this.group.style.webKitFlexDirection = 'column'\r\n    container.appendChild(this.group)\r\n  }\r\n});\r\n\r\nAFRAME.registerComponent('stats-row', {\r\n  multiple: true,\r\n  schema: {\r\n    // name of the group to add the stats row to.\r\n    group: {type: 'string'},\r\n\r\n    // name of an event to listen for\r\n    event: {type: 'string'},\r\n\r\n    // property from event to output in stats panel\r\n    properties: {type: 'array'},\r\n\r\n    // label for the row in the stats panel\r\n    label: {type: 'string'}\r\n  },\r\n\r\n  init () {\r\n\r\n    const groupComponentName = \"stats-group__\" + this.data.group\r\n    const groupComponent = this.el.components[groupComponentName] ||\r\n                           this.el.sceneEl.components[groupComponentName] ||\r\n                           this.el.components[\"stats-group\"] ||\r\n                           this.el.sceneEl.components[\"stats-group\"]\r\n\r\n    if (!groupComponent) {\r\n      console.warn(`Couldn't find stats group ${groupComponentName}`)\r\n      return;\r\n    }\r\n  \r\n    this.counter = document.createElement('div')\r\n    this.counter.classList.add('rs-counter-base')\r\n    groupComponent.group.appendChild(this.counter)\r\n\r\n    this.counterId = document.createElement('div')\r\n    this.counterId.classList.add('rs-counter-id')\r\n    this.counterId.innerHTML = this.data.label\r\n    this.counter.appendChild(this.counterId)\r\n\r\n    this.counterValues = {}\r\n    this.data.properties.forEach((property) => {\r\n      const counterValue = document.createElement('div')\r\n      counterValue.classList.add('rs-counter-value')\r\n      counterValue.innerHTML = \"...\"\r\n      this.counter.appendChild(counterValue)\r\n      this.counterValues[property] = counterValue\r\n    })\r\n\r\n    this.updateData = this.updateData.bind(this)\r\n    this.el.addEventListener(this.data.event, this.updateData)\r\n\r\n    this.splitCache = {}\r\n  },\r\n\r\n  updateData(e) {\r\n    \r\n    this.data.properties.forEach((property) => {\r\n      const split = this.splitDot(property);\r\n      let value = e.detail;\r\n      for (i = 0; i < split.length; i++) {\r\n        value = value[split[i]];\r\n      }\r\n      this.counterValues[property].innerHTML = value\r\n    })\r\n  },\r\n\r\n  splitDot (path) {\r\n    if (path in this.splitCache) { return this.splitCache[path]; }\r\n    this.splitCache[path] = path.split('.');\r\n    return this.splitCache[path];\r\n  }\r\n\r\n});\r\n\n\n//# sourceURL=webpack://@c-frame/physx/./node_modules/aframe-stats-panel/index.js?");

/***/ }),

/***/ "./src/physics.js":
/*!************************!*\
  !*** ./src/physics.js ***!
  \************************/
/***/ (() => {

eval("// This is a modification of the physics/PhysX libraries\r\n//   created by Lee Stemkoski\r\n//   from the VARTISTE project @ https://vartiste.xyz/ \r\n//   by Zachary Capalbo https://github.com/zach-capalbo/vartiste\r\n// with the goal of creating a simplified standalone codebase.\r\n// Further performance modifications by Diarmid Mackenzie.\r\n\r\n// original documentation: https://vartiste.xyz/docs.html#physics.js\r\n\r\n// Came via: https://github.com/stemkoski/A-Frame-Examples/blob/66f05fe5cf89879996f1f6a4c0475ce475e8796a/js/physics.js\r\n// and then via: https://github.com/diarmidmackenzie/christmas-scene/blob/a94ae7e7167937f10d34df8429fb71641e343bb1/lib/physics.js\r\n// ======================================================================\r\n\r\n// patching in Pool functions\r\n\r\nvar poolSize = 0\r\n\r\nfunction sysPool(name, type) {\r\n    if (this.system._pool[name]) return this.system._pool[name]\r\n    this.system._pool[name] = new type()\r\n    // console.log(\"SysPooling\", type.name)\r\n    return this.system._pool[name]\r\n}\r\n\r\nfunction pool(name, type) {\r\n    if (this._pool[name]) return this._pool[name]\r\n    this._pool[name] = new type()\r\n    // console.log(\"Pooling\", type.name)\r\n    return this._pool[name]\r\n}\r\n\r\nclass Pool {\r\n  static init(where, {useSystem = false} = {}) {\r\n    if (useSystem)\r\n    {\r\n      if (!where.system) {\r\n        console.error(\"No system for system pool\", where.attrName)\r\n      }\r\n      if (!where.system._pool) where.system._pool = {};\r\n\r\n      where.pool = sysPool;\r\n    }\r\n    else\r\n    {\r\n      where._pool = {}\r\n      where.pool = pool;\r\n    }\r\n  }\r\n}\r\n\r\n// ==================================================================================================\r\n\r\n// patching in required Util functions from VARTISTE\r\n\r\nUtil = {}\r\n\r\nPool.init(Util);\r\n\r\n// Copies `matrix` into `obj`'s (a `THREE.Object3D`) `matrix`, and decomposes\r\n// it to `obj`'s position, rotation, and scale\r\nUtil.applyMatrix = function(matrix, obj) {\r\n  obj.matrix.copy(matrix)\r\n  matrix.decompose(obj.position, obj.rotation, obj.scale)\r\n}\r\n\r\nUtil.traverseCondition = function(obj3D, condition, fn) \r\n{\r\n  if (!condition(obj3D)) return;\r\n\r\n  fn(obj3D)\r\n  for (let c of obj3D.children)\r\n  {\r\n    this.traverseCondition(c, condition, fn)\r\n  }\r\n}\r\n\r\nUtil.positionObject3DAtTarget = function(obj, target, {scale, transformOffset, transformRoot} = {}) \r\n{\r\n  if (typeof transformRoot === 'undefined') transformRoot = obj.parent\r\n\r\n  target.updateMatrixWorld()\r\n  let destMat = this.pool('dest', THREE.Matrix4)\r\n  destMat.copy(target.matrixWorld)\r\n\r\n  if (transformOffset) {\r\n    let transformMat = this.pool('transformMat', THREE.Matrix4)\r\n    transformMat.makeTranslation(transformOffset.x, transformOffset.y, transformOffset.z)\r\n    destMat.multiply(transformMat)\r\n  }\r\n\r\n  if (scale) {\r\n    let scaleVect = this.pool('scale', THREE.Vector3)\r\n    scaleVect.setFromMatrixScale(destMat)\r\n    scaleVect.set(scale.x / scaleVect.x, scale.y / scaleVect.y, scale.z / scaleVect.z)\r\n    destMat.scale(scaleVect)\r\n  }\r\n\r\n  let invMat = this.pool('inv', THREE.Matrix4)\r\n\r\n  // This seems to be unecessary, and kills performance....\r\n  //transformRoot.updateMatrixWorld()\r\n  invMat.copy(transformRoot.matrixWorld).invert()\r\n  destMat.premultiply(invMat)\r\n\r\n  Util.applyMatrix(destMat, obj)\r\n}\r\n\r\n// untested functions\r\n\r\n// Executes function `fn` when `entity` has finished loading, or immediately\r\n// if it has already loaded. `entity` may be a single `a-entity` element, or\r\n// an array of `a-entity` elements. If `fn` is not provided, it will return a\r\n// `Promise` that will resolve when `entity` is loaded (or immediately if\r\n// `entity` is already loaded).\r\nUtil.whenLoaded = function(entity, fn) {\r\n  if (Array.isArray(entity) && fn) return whenLoadedAll(entity, fn)\r\n  if (Array.isArray(entity)) return awaitLoadingAll(entity)\r\n  if (fn) return whenLoadedSingle(entity, fn)\r\n  return awaitLoadingSingle(entity)\r\n}\r\n\r\nfunction whenLoadedSingle(entity, fn) {\r\n  if (entity.hasLoaded)\r\n  {\r\n    fn()\r\n  }\r\n  else\r\n  {\r\n    entity.addEventListener('loaded', fn)\r\n  }\r\n}\r\n\r\nfunction whenLoadedAll(entities, fn) {\r\n  let allLoaded = entities.map(() => false)\r\n  for (let i = 0; i < entities.length; ++i)\r\n  {\r\n    let ii = i\r\n    let entity = entities[ii]\r\n    whenLoadedSingle(entity, () => {\r\n      allLoaded[ii] = true\r\n      if (allLoaded.every(t => t)) fn()\r\n    })\r\n  }\r\n}\r\n\r\nfunction awaitLoadingSingle(entity) {\r\n  return new Promise((r, e) => whenLoadedSingle(entity, r))\r\n}\r\n\r\nasync function awaitLoadingAll(entities) {\r\n  for (let entity of entities)\r\n  {\r\n    await awaitLoadingSingle(entity)\r\n  }\r\n}\r\n\r\nUtil.whenComponentInitialized = function(el, component, fn) {\r\n  if (el && el.components[component] && el.components[component].initialized) {\r\n    return Promise.resolve(fn ? fn() : undefined)\r\n  }\r\n\r\n  return new Promise((r, e) => {\r\n    if (el && el.components[component] && el.components[component].initialized) {\r\n      return Promise.resolve(fn ? fn() : undefined)\r\n    }\r\n\r\n    let listener = (e) => {\r\n      if (e.detail.name === component) {\r\n        el.removeEventListener('componentinitialized', listener);\r\n        if (fn) fn();\r\n        r();\r\n      }\r\n    };\r\n    el.addEventListener('componentinitialized', listener)\r\n  })\r\n}\r\n\r\n// ========================================================================================\r\n\r\n// Extra utility functions for dealing with PhysX\r\n\r\nconst PhysXUtil = {\r\n    // Gets the world position transform of the given object3D in PhysX format\r\n    object3DPhysXTransform: (() => {\r\n      let pos = new THREE.Vector3();\r\n      let quat = new THREE.Quaternion();\r\n      return function (obj) {\r\n        obj.getWorldPosition(pos);\r\n        obj.getWorldQuaternion(quat);\r\n\r\n        return {\r\n          translation: {\r\n            x: pos.x,\r\n            y: pos.y,\r\n            z: pos.z,\r\n          },\r\n          rotation: {\r\n            w: quat.w, // PhysX uses WXYZ quaternions,\r\n            x: quat.x,\r\n            y: quat.y,\r\n            z: quat.z,\r\n          },\r\n        }\r\n      }\r\n    })(),\r\n\r\n  // Converts a THREE.Matrix4 into a PhysX transform\r\n  matrixToTransform: (() => {\r\n      let pos = new THREE.Vector3();\r\n      let quat = new THREE.Quaternion();\r\n      let scale = new THREE.Vector3();\r\n      let scaleInv = new THREE.Matrix4();\r\n      let mat2 = new THREE.Matrix4();\r\n      return function (matrix) {\r\n        matrix.decompose(pos, quat, scale);\r\n\r\n        return {\r\n          translation: {\r\n            x: pos.x,\r\n            y: pos.y,\r\n            z: pos.z,\r\n          },\r\n          rotation: {\r\n            w: quat.w, // PhysX uses WXYZ quaternions,\r\n            x: quat.x,\r\n            y: quat.y,\r\n            z: quat.z,\r\n          },\r\n        }\r\n      }\r\n    })(),\r\n\r\n  // Converts an arry of layer numbers to an integer bitmask\r\n  layersToMask: (() => {\r\n    let layers = new THREE.Layers();\r\n    return function(layerArray) {\r\n      layers.disableAll();\r\n      for (let layer of layerArray)\r\n      {\r\n          layers.enable(parseInt(layer));\r\n      }\r\n      return layers.mask;\r\n    };\r\n  })(),\r\n\r\n  axisArrayToEnums: function(axes) {\r\n    let enumAxes = []\r\n    for (let axis of axes)\r\n    {\r\n      if (axis === 'swing') {\r\n        enumAxes.push(PhysX.PxD6Axis.eSWING1)\r\n        enumAxes.push(PhysX.PxD6Axis.eSWING2)\r\n        continue\r\n      }\r\n      let enumKey = `e${axis.toUpperCase()}`\r\n      if (!(enumKey in PhysX.PxD6Axis))\r\n      {\r\n        console.warn(`Unknown axis ${axis} (PxD6Axis::${enumKey})`)\r\n      }\r\n      enumAxes.push(PhysX.PxD6Axis[enumKey])\r\n    }\r\n    return enumAxes;\r\n  }\r\n};\r\n\r\nlet PhysX\r\n\r\n// Implements the a physics system using an emscripten compiled PhysX engine.\r\n//\r\n//\r\n// If `autoLoad` is `true`, or when you call `startPhysX`, the `physx` system will\r\n// automatically load and initialize the physics system with reasonable defaults\r\n// and a ground plane. All you have to do is add [`physx-body`](#physx-body) to\r\n// the bodies that you want to be part of the simulation. The system will take\r\n// try to take care of things like collision meshes, position updates, etc\r\n// automatically.  The simplest physics scene looks something like:\r\n//\r\n//```\r\n// <a-scene physx=\"autoLoad: true\">\r\n//  <a-assets><a-asset-item id=\"#mymodel\" src=\"...\"></a-asset-item></a-assets>\r\n//\r\n//  <a-box physx-body=\"type: static\" color=\"green\" position=\"0 0 -3\"></a-box>\r\n//  <a-sphere physx-body=\"type: dynamic\" position=\"0.4 2 -3\" color=\"blue\"></a-sphere>\r\n//  <a-entity physx-body=\"type: dynamic\" position=\"0 5 -3\" gltf-model=\"#mymodel\"></a-entity>\r\n// </a-scene>\r\n//```\r\n//\r\n// If you want a little more control over how things behave, you can set the\r\n// [`physx-material`](#physx-material) component on the objects in your\r\n// simulation, or use [`physx-joint`s](#physx-joint),\r\n// [`physx-constraint`s](#physx-constraint) and [`physx-driver`s](#physx-driver)\r\n// to add some complexity to your scene.\r\n//\r\n// If you need more low-level control, the PhysX bindings are exposed through\r\n// the `PhysX` property of the system. So for instance, if you wanted to make\r\n// use of the [`PxCapsuleGeometry`](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxapi/files/classPxCapsuleGeometry.html)\r\n// in your own component, you would call:\r\n//\r\n//```\r\n//    let myGeometry = new this.el.sceneEl.PhysX.PxCapsuleGeometry(1.0, 2.0)\r\n//```\r\n//\r\n// The system uses [my fork](https://github.com/zach-capalbo/PhysX) of PhysX, built using the [Docker Wrapper](https://github.com/ashconnell/physx-js). To see what's exposed to JavaScript, see [PxWebBindings.cpp](https://github.com/zach-capalbo/PhysX/blob/emscripten_wip/physx/source/physxwebbindings/src/PxWebBindings.cpp)\r\n//\r\n// For a complete example of how to use this, you can see the\r\n// [aframe-vartiste-toolkit Physics\r\n// Playground](https://glitch.com/edit/#!/fascinated-hip-period?path=index.html)\r\n//\r\n// It is also helpful to refer to the [NVIDIA PhysX\r\n// documentation](https://gameworksdocs.nvidia.com/PhysX/4.0/documentation/PhysXGuide/Manual/Index.html)\r\nAFRAME.registerSystem('physx', {\r\n  schema: {\r\n    // Amount of time to wait after loading before starting the physics. Can be\r\n    // useful if there is still some things loading or initializing elsewhere in\r\n    // the scene\r\n    delay: {default: 5000},\r\n\r\n    // Throttle for running the physics simulation. On complex scenes, you can\r\n    // increase this to avoid dropping video frames\r\n    throttle: {default: 10},\r\n\r\n    // If true, the PhysX will automatically be loaded and started. If false,\r\n    // you will have to call `startPhysX()` manually to load and start the\r\n    // physics engine\r\n    autoLoad: {default: false},\r\n\r\n    // Simulation speed multiplier. Increase or decrease to speed up or slow\r\n    // down simulation time\r\n    speed: {default: 1.0},\r\n\r\n    // URL for the PhysX WASM bundle.\r\n    wasmUrl: {default: \"https://cdn.jsdelivr.net/gh/c-frame/physx/wasm/physx.release.wasm\"},\r\n\r\n    // If true, sets up a default scene with a ground plane and bounding\r\n    // cylinder.\r\n    useDefaultScene: {default: true},\r\n\r\n    // NYI\r\n    wrapBounds: {default: false},\r\n\r\n    // Which collision layers the ground belongs to\r\n    groundCollisionLayers: {default: [2]},\r\n\r\n    // Which collision layers will collide with the ground\r\n    groundCollisionMask: {default: [1,2,3,4]},\r\n\r\n    // Global gravity vector\r\n    gravity: {type: 'vec3', default: {x: 0, y: -9.8, z: 0}},\r\n  },\r\n  init() {\r\n    this.PhysXUtil = PhysXUtil;\r\n\r\n    // for logging.\r\n    this.cumTimeEngine = 0;\r\n    this.cumTimeWrapper = 0;\r\n    this.tickCounter = 0;\r\n\r\n\r\n    this.objects = new Map();\r\n    this.shapeMap = new Map();\r\n    this.jointMap = new Map();\r\n    this.boundaryShapes = new Set();\r\n    this.worldHelper = new THREE.Object3D();\r\n    this.el.object3D.add(this.worldHelper);\r\n    this.tock = AFRAME.utils.throttleTick(this.tock, this.data.throttle, this)\r\n    this.collisionObject = {thisShape: null, otherShape:null, points: [], impulses: [], otherComponent: null};\r\n\r\n    let defaultTarget = document.createElement('a-entity')\r\n    this.el.append(defaultTarget)\r\n    this.defaultTarget = defaultTarget\r\n\r\n    this.initializePhysX = new Promise((r, e) => {\r\n      this.fulfillPhysXPromise = r;\r\n    })\r\n\r\n    this.el.addEventListener('inspectortoggle', (e) => {\r\n      console.log(\"Inspector toggle\", e)\r\n      if (e.detail === true)\r\n      {\r\n          this.running = false\r\n      }\r\n    })\r\n  },\r\n  findWasm() {\r\n    return this.data.wasmUrl;\r\n  },\r\n  // Loads PhysX and starts the simulation\r\n  async startPhysX() {\r\n    this.running = true;\r\n    let self = this;\r\n    let resolveInitialized;\r\n    let initialized = new Promise((r, e) => resolveInitialized = r)\r\n    PhysX = PHYSX({\r\n        locateFile() {\r\n            return self.findWasm()\r\n        },\r\n        onRuntimeInitialized() {\r\n          resolveInitialized();\r\n        }\r\n      });\r\n    if (PhysX instanceof Promise) PhysX = await PhysX;\r\n    this.PhysX = PhysX;\r\n    await initialized;\r\n    self.startPhysXScene()\r\n    self.physXInitialized = true\r\n    self.fulfillPhysXPromise()\r\n    self.el.emit('physx-started', {})\r\n  },\r\n  startPhysXScene() {\r\n    console.info(\"Starting PhysX scene\")\r\n    const foundation = PhysX.PxCreateFoundation(\r\n      PhysX.PX_PHYSICS_VERSION,\r\n      new PhysX.PxDefaultAllocator(),\r\n      new PhysX.PxDefaultErrorCallback()\r\n    );\r\n    this.foundation = foundation\r\n    const physxSimulationCallbackInstance = PhysX.PxSimulationEventCallback.implement({\r\n      onContactBegin: (shape0, shape1, points, impulses) => {\r\n        let c0 = this.shapeMap.get(shape0.$$.ptr)\r\n        let c1 = this.shapeMap.get(shape1.$$.ptr)\r\n\r\n        if (c1 === c0) return;\r\n\r\n        if (c0 && c0.data.emitCollisionEvents) {\r\n          this.collisionObject.thisShape = shape0\r\n          this.collisionObject.otherShape = shape1\r\n          this.collisionObject.points = points\r\n          this.collisionObject.impulses = impulses\r\n          this.collisionObject.otherComponent = c1\r\n          c0.el.emit('contactbegin', this.collisionObject)\r\n        }\r\n\r\n        if (c1 && c1.data.emitCollisionEvents) {\r\n          this.collisionObject.thisShape = shape1\r\n          this.collisionObject.otherShape = shape0\r\n          this.collisionObject.points = points\r\n          this.collisionObject.impulses = impulses\r\n          this.collisionObject.otherComponent = c0\r\n          c1.el.emit('contactbegin', this.collisionObject)\r\n        }\r\n      },\r\n      onContactEnd: (shape0, shape1) => {\r\n          let c0 = this.shapeMap.get(shape0.$$.ptr)\r\n          let c1 = this.shapeMap.get(shape1.$$.ptr)\r\n\r\n          if (c1 === c0) return;\r\n\r\n        if (c0 && c0.data.emitCollisionEvents) {\r\n          this.collisionObject.thisShape = shape0\r\n          this.collisionObject.otherShape = shape1\r\n          this.collisionObject.points = null\r\n          this.collisionObject.impulses = null\r\n          this.collisionObject.otherComponent = c1\r\n          c0.el.emit('contactend', this.collisionObject)\r\n        }\r\n\r\n        if (c1 && c1.data.emitCollisionEvents) {\r\n          this.collisionObject.thisShape = shape1\r\n          this.collisionObject.otherShape = shape0\r\n          this.collisionObject.points = null\r\n          this.collisionObject.impulses = null\r\n          this.collisionObject.otherComponent = c0\r\n          c1.el.emit('contactend', this.collisionObject)\r\n        }\r\n      },\r\n      onContactPersist: () => {},\r\n      onTriggerBegin: () => {},\r\n      onTriggerEnd: () => {},\r\n      onConstraintBreak: (joint) => {\r\n        let component = this.jointMap.get(joint.$$.ptr);\r\n\r\n        if (!component) return;\r\n\r\n        component.el.emit('constraintbreak', {})\r\n      },\r\n    });\r\n    let tolerance = new PhysX.PxTolerancesScale();\r\n    // tolerance.length /= 10;\r\n    // console.log(\"Tolerances\", tolerance.length, tolerance.speed);\r\n    this.physics = PhysX.PxCreatePhysics(\r\n      PhysX.PX_PHYSICS_VERSION,\r\n      foundation,\r\n      tolerance,\r\n      false,\r\n      null\r\n    )\r\n    PhysX.PxInitExtensions(this.physics, null);\r\n\r\n    this.cooking = PhysX.PxCreateCooking(\r\n      PhysX.PX_PHYSICS_VERSION,\r\n      foundation,\r\n      new PhysX.PxCookingParams(tolerance)\r\n    )\r\n\r\n    const sceneDesc = PhysX.getDefaultSceneDesc(\r\n      this.physics.getTolerancesScale(),\r\n      0,\r\n      physxSimulationCallbackInstance\r\n    )\r\n    this.scene = this.physics.createScene(sceneDesc)\r\n\r\n    this.setupDefaultEnvironment()\r\n  },\r\n  setupDefaultEnvironment() {\r\n    this.defaultActorFlags = new PhysX.PxShapeFlags(\r\n      PhysX.PxShapeFlag.eSCENE_QUERY_SHAPE.value |\r\n        PhysX.PxShapeFlag.eSIMULATION_SHAPE.value\r\n    )\r\n    this.defaultFilterData = new PhysX.PxFilterData(PhysXUtil.layersToMask(this.data.groundCollisionLayers), PhysXUtil.layersToMask(this.data.groundCollisionMask), 0, 0);\r\n\r\n    this.scene.setGravity(this.data.gravity)\r\n\r\n    if (this.data.useDefaultScene)\r\n    {\r\n      this.createGroundPlane()\r\n      this.createBoundingCylinder()\r\n    }\r\n\r\n\r\n    this.defaultTarget.setAttribute('physx-body', 'type', 'static')\r\n\r\n  },\r\n  createGroundPlane() {\r\n    let geometry = new PhysX.PxPlaneGeometry();\r\n    // let geometry = new PhysX.PxBoxGeometry(10, 1, 10);\r\n    let material = this.physics.createMaterial(0.8, 0.8, 0.1);\r\n\r\n    const shape = this.physics.createShape(geometry, material, false, this.defaultActorFlags)\r\n    shape.setQueryFilterData(this.defaultFilterData)\r\n    shape.setSimulationFilterData(this.defaultFilterData)\r\n        const transform = {\r\n      translation: {\r\n        x: 0,\r\n        y: 0,\r\n        z: -5,\r\n      },\r\n      rotation: {\r\n        w: 0.707107, // PhysX uses WXYZ quaternions,\r\n        x: 0,\r\n        y: 0,\r\n        z: 0.707107,\r\n      },\r\n    }\r\n    let body = this.physics.createRigidStatic(transform)\r\n    body.attachShape(shape)\r\n    this.scene.addActor(body, null)\r\n    this.ground = body\r\n    this.rigidBody = body\r\n  },\r\n  createBoundingCylinder() {\r\n    const numPlanes = 16\r\n    let geometry = new PhysX.PxPlaneGeometry();\r\n    let material = this.physics.createMaterial(0.1, 0.1, 0.8);\r\n    let spherical = new THREE.Spherical();\r\n    spherical.radius = 30;\r\n    let quat = new THREE.Quaternion();\r\n    let pos = new THREE.Vector3;\r\n    let euler = new THREE.Euler();\r\n\r\n    for (let i = 0; i < numPlanes; ++i)\r\n    {\r\n      spherical.theta = i * 2.0 * Math.PI / numPlanes;\r\n      pos.setFromSphericalCoords(spherical.radius, spherical.theta, spherical.phi)\r\n      pos.x = - pos.y\r\n      pos.y = 0;\r\n      euler.set(0, spherical.theta, 0);\r\n      quat.setFromEuler(euler)\r\n\r\n      const shape = this.physics.createShape(geometry, material, false, this.defaultActorFlags)\r\n      shape.setQueryFilterData(this.defaultFilterData)\r\n      shape.setSimulationFilterData(this.defaultFilterData)\r\n      const transform = {\r\n        translation: {\r\n          x: pos.x,\r\n          y: pos.y,\r\n          z: pos.z,\r\n        },\r\n        rotation: {\r\n          w: quat.w, // PhysX uses WXYZ quaternions,\r\n          x: quat.x,\r\n          y: quat.y,\r\n          z: quat.z,\r\n        },\r\n      }\r\n      this.boundaryShapes.add(shape.$$.ptr)\r\n      let body = this.physics.createRigidStatic(transform)\r\n      body.attachShape(shape)\r\n      this.scene.addActor(body, null)\r\n    }\r\n  },\r\n  async registerComponentBody(component, {type}) {\r\n    await this.initializePhysX;\r\n\r\n    // const shape = this.physics.createShape(geometry, material, false, flags)\r\n    const transform = PhysXUtil.object3DPhysXTransform(component.el.object3D);\r\n\r\n    let body\r\n    if (type === 'dynamic' || type === 'kinematic')\r\n    {\r\n      body = this.physics.createRigidDynamic(transform)\r\n\r\n      // body.setRigidBodyFlag(PhysX.PxRigidBodyFlag.eENABLE_CCD, true);\r\n      // body.setMaxContactImpulse(1e2);\r\n    }\r\n    else\r\n    {\r\n      body = this.physics.createRigidStatic(transform)\r\n    }\r\n\r\n    let attemptToUseDensity = true;\r\n    let seenAnyDensity = false;\r\n    let densities = new PhysX.VectorPxReal()\r\n    for (let shape of component.createShapes(this.physics, this.defaultActorFlags))\r\n    {\r\n      body.attachShape(shape)\r\n\r\n      if (isFinite(shape.density))\r\n      {\r\n        seenAnyDensity = true\r\n        densities.push_back(shape.density)\r\n      }\r\n      else\r\n      {\r\n        attemptToUseDensity = false\r\n\r\n        if (seenAnyDensity)\r\n        {\r\n          console.warn(\"Densities not set for all shapes. Will use total mass instead.\", component.el)\r\n        }\r\n      }\r\n    }\r\n    if (type === 'dynamic' || type === 'kinematic') {\r\n      if (attemptToUseDensity && seenAnyDensity)\r\n      {\r\n        console.log(\"Setting density vector\", densities)\r\n        body.updateMassAndInertia(densities)\r\n      }\r\n      else {\r\n        body.setMassAndUpdateInertia(component.data.mass)\r\n      }\r\n    }\r\n    densities.delete()\r\n    this.scene.addActor(body, null)\r\n    this.objects.set(component.el.object3D, body)\r\n    component.rigidBody = body\r\n  },\r\n  registerShape(shape, component) {\r\n    this.shapeMap.set(shape.$$.ptr, component);\r\n  },\r\n  registerJoint(joint, component) {\r\n    this.jointMap.set(joint.$$.ptr, component);\r\n  },\r\n  removeBody(component) {\r\n    let body = component.rigidBody\r\n    this.objects.delete(component.el.object3D)\r\n    body.release()\r\n  },\r\n  tock(t, dt) {\r\n    if (t < this.data.delay) return\r\n    if (!this.physXInitialized && this.data.autoLoad && !this.running) this.startPhysX()\r\n    if (!this.physXInitialized) return\r\n    if (!this.running) return\r\n\r\n    const startTime = Date.now();\r\n\r\n    this.scene.simulate(THREE.MathUtils.clamp(dt * this.data.speed / 1000, 0, 0.03 * this.data.speed), true)\r\n    //this.scene.simulate(0.02, true) // (experiment with fixed interval)\r\n    this.scene.fetchResults(true)\r\n\r\n    const engineEndTime = Date.now();\r\n    this.cumTimeEngine += engineEndTime;\r\n    this.cumTimeEngine -= startTime;\r\n    this.tickCounter++;\r\n\r\n    for (let [obj, body] of this.objects)\r\n    {\r\n        // no updates needed for static objects.\r\n        if (obj.el.components['physx-body'].data.type === 'static') continue;\r\n\r\n        const transform = body.getGlobalPose()\r\n        this.worldHelper.position.copy(transform.translation);\r\n        this.worldHelper.quaternion.copy(transform.rotation);\r\n        obj.getWorldScale(this.worldHelper.scale)\r\n        Util.positionObject3DAtTarget(obj, this.worldHelper);\r\n    }\r\n\r\n    const wrapperEndTime = Date.now();\r\n    this.cumTimeWrapper += wrapperEndTime;\r\n    this.cumTimeWrapper -= engineEndTime;\r\n\r\n    if (this.tickCounter === 100) {\r\n        console.log(`Avg. physics tick duration (engine): ${this.cumTimeEngine / 100} msecs`);\r\n        console.log(`Avg. physics tick duration (wrapper): ${this.cumTimeWrapper / 100} msecs`);\r\n        this.el.emit(\"physics-tick-timer\", {engine: this.cumTimeEngine / 100,\r\n                                            wrapper: this.cumTimeWrapper / 100})\r\n        this.tickCounter = 0;\r\n        this.cumTimeEngine = 0;\r\n        this.cumTimeWrapper = 0;\r\n    }\r\n  }\r\n})\r\n\r\n// Controls physics properties for individual shapes or rigid bodies. You can\r\n// set this either on an entity with the `phyx-body` component, or on a shape or\r\n// model contained in an entity with the `physx-body` component. If it's set on\r\n// a `physx-body`, it will be the default material for all shapes in that body.\r\n// If it's set on an element containing geometry or a model, it will be the\r\n// material used for that shape only.\r\n//\r\n// For instance, in the following scene fragment:\r\n//```\r\n// <a-entity id=\"bodyA\" physx-body physx-material=\"staticFriction: 0.5\">\r\n//   <a-box id=\"shape1\" physx-material=\"staticFriction: 1.0\"></a-box>\r\n//   <a-sphere id=\"shape2\"></a-sphere>\r\n// </a-entity>\r\n// <a-cone id=\"bodyB\" physx-body></a-cone>\r\n//```\r\n//\r\n// `shape1`, which is part of the `bodyA` rigid body, will have static friction\r\n// of 1.0, since it has a material set on it. `shape2`, which is also part of\r\n// the `bodyA` rigid body, will have a static friction of 0.5, since that is\r\n// the body default. `bodyB` will have the component default of 0.2, since it is\r\n// a separate body.\r\nAFRAME.registerComponent('physx-material', {\r\n  schema: {\r\n    // Static friction\r\n    staticFriction: {default: 0.2},\r\n    // Dynamic friction\r\n    dynamicFriction: {default: 0.2},\r\n    // Restitution, or \"bounciness\"\r\n    restitution: {default: 0.2},\r\n\r\n    // Density for the shape. If densities are specified for _all_ shapes in a\r\n    // rigid body, then the rigid body's mass properties will be automatically\r\n    // calculated based on the different densities. However, if density\r\n    // information is not specified for every shape, then the mass defined in\r\n    // the overarching [`physx-body`](#physx-body) will be used instead.\r\n    density: {type: 'number', default: NaN},\r\n\r\n    // Which collision layers this shape is present on\r\n    collisionLayers: {default: [1], type: 'array'},\r\n    // Array containing all layers that this shape should collide with\r\n    collidesWithLayers: {default: [1,2,3,4], type: 'array'},\r\n\r\n    // If `collisionGroup` is greater than 0, this shape will *not* collide with\r\n    // any other shape with the same `collisionGroup` value\r\n    collisionGroup: {default: 0},\r\n\r\n    // If >= 0, this will set the PhysX contact offset, indicating how far away\r\n    // from the shape simulation contact events should begin.\r\n    contactOffset: {default: -1.0},\r\n\r\n    // If >= 0, this will set the PhysX rest offset\r\n    restOffset: {default: -1.0},\r\n  }\r\n})\r\n\r\n// Turns an entity into a PhysX rigid body. This is the main component for\r\n// creating physics objects.\r\n//\r\n// **Types**\r\n//\r\n// There are 3 types of supported rigid bodies. The type can be set by using the\r\n// `type` proeprty, but once initialized cannot be changed.\r\n//\r\n// - `dynamic` objects are objects that will have physics simulated on them. The\r\n//   entity's world position, scale, and rotation will be used as the starting\r\n//   condition for the simulation, however once the simulation starts the\r\n//   entity's position and rotation will be replaced each frame with the results\r\n//   of the simulation.\r\n// - `static` objects are objects that cannot move. They cab be used to create\r\n//   collidable objects for `dynamic` objects, or for anchor points for joints.\r\n// - `kinematic` objects are objects that can be moved programmatically, but\r\n//   will not be moved by the simulation. They can however, interact with and\r\n//   collide with dynamic objects. Each frame, the entity's `object3D` will be\r\n//   used to set the position and rotation for the simulation object.\r\n//\r\n// **Shapes**\r\n//\r\n// When the component is initialized, and on the `object3dset` event, all\r\n// visible meshes that are descendents of this entity will have shapes created\r\n// for them. Each individual mesh will have its own convex hull automatically\r\n// generated for it. This means you can have reasonably accurate collision\r\n// meshes both from building up shapes with a-frame geometry primitives, and\r\n// from importing 3D models.\r\n//\r\n// Visible meshes can be excluded from this shape generation process by setting\r\n// the `physx-no-collision` attribute on the corresponding `a-entity` element.\r\n// Invisible meshes can be included into this shape generation process by\r\n// settingt the `physx-hidden-collision` attribute on the corresponding\r\n// `a-entity` element. This can be especially useful when using an external tool\r\n// (like [Blender V-HACD](https://github.com/andyp123/blender_vhacd)) to create\r\n// a low-poly convex collision mesh for a high-poly or concave mesh. This leads\r\n// to this pattern for such cases:\r\n//\r\n// ```\r\n//    <a-entity physx-body=\"type: dynamic\">\r\n//      <a-entity gltf-model=\"HighPolyOrConcaveURL.gltf\" physx-no-collision=\"\"></a-entity>\r\n//      <a-entity gltf-model=\"LowPolyConvexURL.gltf\" physx-hidden-collision=\"\" visible=\"false\"></a-entity>\r\n//    </a-entity>\r\n// ```\r\n//\r\n// Note, in such cases that if you are setting material properties on individual\r\n// shapes, then the property should go on the collision mesh entity\r\n//\r\n// **Use with the [Manipulator](#manipulator) component**\r\n//\r\n// If a dynamic entity is grabbed by the [Manipulator](#manipulator) component,\r\n// it will temporarily become a kinematic object. This means that collisions\r\n// will no longer impede its movement, and it will track the manipulator\r\n// exactly, (subject to any manipulator constraints, such as\r\n// [`manipulator-weight`](#manipulator-weight)). If you would rather have the\r\n// object remain dynamic, you will need to [redirect the grab](#redirect-grab)\r\n// to a `physx-joint` instead, or even easier, use the\r\n// [`dual-wieldable`](#dual-wieldable) component.\r\n//\r\n// As soon as the dynamic object is released, it will revert back to a dynamic\r\n// object. Objects with the type `kinematic` will remain kinematic.\r\n//\r\n// Static objects should not be moved. If a static object can be the target of a\r\n// manipulator grab (or any other kind of movement), it should be `kinematic`\r\n// instead.\r\nAFRAME.registerComponent('physx-body', {\r\n  dependencies: ['physx-material'],\r\n  schema: {\r\n    // **[dynamic, static, kinematic]** Type of the rigid body to create\r\n    type: {default: 'dynamic', oneOf: ['dynamic', 'static', 'kinematic']},\r\n\r\n    // Total mass of the body\r\n    mass: {default: 1.0},\r\n\r\n    // If > 0, will set the rigid body's angular damping\r\n    angularDamping: {default: 0.0},\r\n\r\n    // If > 0, will set the rigid body's linear damping\r\n    linearDamping: {default: 0.0},\r\n\r\n    // If set to `true`, it will emit `contactbegin` and `contactend` events\r\n    // when collisions occur\r\n    emitCollisionEvents: {default: false},\r\n\r\n    // If set to `true`, the object will receive extra attention by the\r\n    // simulation engine (at a performance cost).\r\n    highPrecision: {default: false},\r\n\r\n    shapeOffset: {type: 'vec3', default: {x: 0, y: 0, z: 0}}\r\n  },\r\n  events: {\r\n    stateadded: function(e) {\r\n      if (e.detail === 'grabbed') {\r\n        this.rigidBody.setRigidBodyFlag(PhysX.PxRigidBodyFlag.eKINEMATIC, true)\r\n      }\r\n    },\r\n    stateremoved: function(e) {\r\n      if (e.detail === 'grabbed') {\r\n        if (this.floating) {\r\n          this.rigidBody.setLinearVelocity({x: 0, y: 0, z: 0}, true)\r\n        }\r\n        if (this.data.type !== 'kinematic')\r\n        {\r\n          this.rigidBody.setRigidBodyFlag(PhysX.PxRigidBodyFlag.eKINEMATIC, false)\r\n        }\r\n      }\r\n    },\r\n    'bbuttonup': function(e) {\r\n      this.toggleGravity()\r\n    },\r\n    componentchanged: function(e) {\r\n      if (e.name === 'physx-material')\r\n      {\r\n        this.el.emit('object3dset', {})\r\n      }\r\n    },\r\n    object3dset: function(e) {\r\n      if (this.rigidBody) {\r\n        for (let shape of this.shapes)\r\n        {\r\n            this.rigidBody.detachShape(shape, false)\r\n        }\r\n\r\n        let attemptToUseDensity = true;\r\n        let seenAnyDensity = false;\r\n        let densities = new PhysX.VectorPxReal()\r\n        let component = this\r\n        let type = this.data.type\r\n        let body = this.rigidBody\r\n        for (let shape of component.createShapes(this.system.physics, this.system.defaultActorFlags))\r\n        {\r\n          body.attachShape(shape)\r\n\r\n          if (isFinite(shape.density))\r\n          {\r\n            seenAnyDensity = true\r\n            densities.push_back(shape.density)\r\n          }\r\n          else\r\n          {\r\n            attemptToUseDensity = false\r\n\r\n            if (seenAnyDensity)\r\n            {\r\n              console.warn(\"Densities not set for all shapes. Will use total mass instead.\", component.el)\r\n            }\r\n          }\r\n        }\r\n        if (type === 'dynamic' || type === 'kinematic') {\r\n          if (attemptToUseDensity && seenAnyDensity)\r\n          {\r\n            console.log(\"Setting density vector\", densities)\r\n            body.updateMassAndInertia(densities)\r\n          }\r\n          else {\r\n            body.setMassAndUpdateInertia(component.data.mass)\r\n          }\r\n        }\r\n      }\r\n    },\r\n    contactbegin: function(e) {\r\n      // console.log(\"Collision\", e.detail.points)\r\n    }\r\n  },\r\n  init() {\r\n    this.system = this.el.sceneEl.systems.physx\r\n    this.physxRegisteredPromise = this.system.registerComponentBody(this, {type: this.data.type})\r\n    this.el.setAttribute('grab-options', 'scalable', false)\r\n\r\n    this.kinematicMove = this.kinematicMove.bind(this)\r\n    if (this.el.sceneEl.systems['button-caster'])\r\n    {\r\n      this.el.sceneEl.systems['button-caster'].install(['bbutton'])\r\n    }\r\n\r\n    this.physxRegisteredPromise.then(() => this.update())\r\n  },\r\n  update(oldData) {\r\n    if (!this.rigidBody) return;\r\n\r\n    if (this.data.type === 'dynamic')\r\n    {\r\n      this.rigidBody.setAngularDamping(this.data.angularDamping)\r\n      this.rigidBody.setLinearDamping(this.data.linearDamping)\r\n      this.rigidBody.setRigidBodyFlag(PhysX.PxRigidBodyFlag.eKINEMATIC, false)\r\n      if (this.data.highPrecision)\r\n      {\r\n        this.rigidBody.setSolverIterationCounts(4, 2);\r\n        this.rigidBody.setRigidBodyFlag(PhysX.PxRigidBodyFlag.eENABLE_CCD, true)\r\n      }\r\n    }\r\n\r\n    if (!oldData || this.data.mass !== oldData.mass) this.el.emit('object3dset', {})\r\n  },\r\n  remove() {\r\n    this.system.removeBody(this)\r\n  },\r\n  createGeometry(o) {\r\n    if (o.el.hasAttribute('geometry'))\r\n    {\r\n      let geometry = o.el.getAttribute('geometry');\r\n      switch(geometry.primitive)\r\n      {\r\n        case 'sphere':\r\n          return new PhysX.PxSphereGeometry(geometry.radius * this.el.object3D.scale.x * 0.98)\r\n        case 'box':\r\n          return new PhysX.PxBoxGeometry(geometry.width / 2, geometry.height / 2, geometry.depth / 2)\r\n        default:\r\n          return this.createConvexMeshGeometry(o.el.getObject3D('mesh'));\r\n      }\r\n    }\r\n  },\r\n  createConvexMeshGeometry(mesh, rootAncestor) {\r\n    let vectors = new PhysX.PxVec3Vector()\r\n\r\n    let g = mesh.geometry.attributes.position\r\n    if (!g) return;\r\n    if (g.count < 3) return;\r\n    if (g.itemSize != 3) return;\r\n    let t = new THREE.Vector3;\r\n\r\n    if (rootAncestor)\r\n    {\r\n      let matrix = new THREE.Matrix4();\r\n      mesh.updateMatrix();\r\n      matrix.copy(mesh.matrix)\r\n      let ancestor = mesh.parent;\r\n      while(ancestor && ancestor !== rootAncestor)\r\n      {\r\n          ancestor.updateMatrix();\r\n          matrix.premultiply(ancestor.matrix);\r\n          ancestor = ancestor.parent;\r\n      }\r\n      for (let i = 0; i < g.count; ++i) {\r\n        t.fromBufferAttribute(g, i)\r\n        t.applyMatrix4(matrix);\r\n        vectors.push_back(Object.assign({}, t));\r\n      }\r\n    }\r\n    else\r\n    {\r\n      for (let i = 0; i < g.count; ++i) {\r\n        t.fromBufferAttribute(g, i)\r\n        vectors.push_back(Object.assign({}, t));\r\n      }\r\n    }\r\n\r\n    let worldScale = new THREE.Vector3;\r\n    let worldBasis = (rootAncestor || mesh);\r\n    worldBasis.updateMatrixWorld();\r\n    worldBasis.getWorldScale(worldScale);\r\n    let convexMesh = this.system.cooking.createConvexMesh(vectors, this.system.physics)\r\n    return new PhysX.PxConvexMeshGeometry(convexMesh, new PhysX.PxMeshScale({x: worldScale.x, y: worldScale.y, z: worldScale.z}, {w: 1, x: 0, y: 0, z: 0}), new PhysX.PxConvexMeshGeometryFlags(PhysX.PxConvexMeshGeometryFlag.eTIGHT_BOUNDS.value))\r\n  },\r\n  createShape(physics, geometry, materialData)\r\n  {\r\n    let material = physics.createMaterial(materialData.staticFriction, materialData.dynamicFriction, materialData.restitution);\r\n    let shape = physics.createShape(geometry, material, false, this.system.defaultActorFlags)\r\n    shape.setQueryFilterData(new PhysX.PxFilterData(PhysXUtil.layersToMask(materialData.collisionLayers), PhysXUtil.layersToMask(materialData.collidesWithLayers), materialData.collisionGroup, 0))\r\n    shape.setSimulationFilterData(new PhysX.PxFilterData(PhysXUtil.layersToMask(materialData.collisionLayers), PhysXUtil.layersToMask(materialData.collidesWithLayers), materialData.collisionGroup, 0))\r\n\r\n    if (materialData.contactOffset >= 0.0)\r\n    {\r\n      shape.setContactOffset(materialData.contactOffset)\r\n    }\r\n    if (materialData.restOffset >= 0.0)\r\n    {\r\n      shape.setRestOffset(materialData.restOffset)\r\n    }\r\n\r\n    shape.density = materialData.density;\r\n    this.system.registerShape(shape, this)\r\n\r\n    return shape;\r\n  },\r\n  createShapes(physics) {\r\n    if (this.el.hasAttribute('geometry'))\r\n    {\r\n      let geometry = this.createGeometry(this.el.object3D);\r\n      if (!geometry) return;\r\n      let materialData = this.el.components['physx-material'].data\r\n      this.shapes = [this.createShape(physics, geometry, materialData)];\r\n\r\n      return this.shapes;\r\n    }\r\n\r\n    let shapes = []\r\n    Util.traverseCondition(this.el.object3D,\r\n      o => {\r\n        if (o.el && o.el.hasAttribute(\"physx-no-collision\")) return false;\r\n        if (o.el && !o.el.object3D.visible && !o.el.hasAttribute(\"physx-hidden-collision\")) return false;\r\n        if (!o.visible && o.el && !o.el.hasAttribute(\"physx-hidden-collision\")) return false;\r\n        if (o.userData && o.userData.vartisteUI) return false;\r\n        return true\r\n      },\r\n      o => {\r\n      if (o.geometry) {\r\n        let geometry;\r\n        if (false)\r\n        {}\r\n        else\r\n        {\r\n          geometry = this.createConvexMeshGeometry(o, this.el.object3D);\r\n        }\r\n        if (!geometry) {\r\n          console.warn(\"Couldn't create geometry\", o)\r\n          return;\r\n        }\r\n\r\n        let material, materialData;\r\n        if (o.el && o.el.hasAttribute('physx-material'))\r\n        {\r\n          materialData = o.el.getAttribute('physx-material')\r\n        }\r\n        else\r\n        {\r\n            materialData = this.el.components['physx-material'].data\r\n        }\r\n        let shape = this.createShape(physics, geometry, materialData)\r\n\r\n        // shape.setLocalPose({translation: this.data.shapeOffset, rotation: {w: 1, x: 0, y: 0, z: 0}})\r\n\r\n        shapes.push(shape)\r\n      }\r\n    });\r\n\r\n    this.shapes = shapes\r\n\r\n    return shapes\r\n  },\r\n  // Turns gravity on and off\r\n  toggleGravity() {\r\n    this.rigidBody.setActorFlag(PhysX.PxActorFlag.eDISABLE_GRAVITY, !this.floating)\r\n    this.floating = !this.floating\r\n  },\r\n  resetBodyPose() {\r\n    this.rigidBody.setGlobalPose(PhysXUtil.object3DPhysXTransform(this.el.object3D), true)\r\n  },\r\n  kinematicMove() {\r\n    this.rigidBody.setKinematicTarget(PhysXUtil.object3DPhysXTransform(this.el.object3D))\r\n  },\r\n  tock(t, dt) {\r\n    if (this.rigidBody && this.data.type === 'kinematic' && !this.setKinematic)\r\n    {\r\n      this.rigidBody.setRigidBodyFlag(PhysX.PxRigidBodyFlag.eKINEMATIC, true)\r\n      this.setKinematic = true\r\n    }\r\n    if (this.rigidBody && (this.data.type === 'kinematic' || this.el.is(\"grabbed\"))) {\r\n      // this.el.object3D.scale.set(1,1,1)\r\n      this.kinematicMove()\r\n    }\r\n  }\r\n})\r\n\r\n// Creates a driver which exerts force to return the joint to the specified\r\n// (currently only the initial) position with the given velocity\r\n// characteristics.\r\n//\r\n// This can only be used on an entity with a `physx-joint` component. Currently\r\n// only supports **D6** joint type. E.g.\r\n//\r\n//```\r\n// <a-box physx-body>\r\n//    <a-entity position=\"0.2 0.3 0.4\" rotation=\"0 90 0\"\r\n//              physx-joint=\"type: D6; target: #other-body\"\r\n//              physx-joint-driver=\"axes: swing, twist; stiffness: 30; angularVelocity: 3 3 0\">\r\n//    </a-entity>\r\n// </a-box>\r\n//```\r\nAFRAME.registerComponent('physx-joint-driver', {\r\n  dependencies: ['physx-joint'],\r\n  multiple: true,\r\n  schema: {\r\n    // Which axes the joint should operate on. Should be some combination of `x`, `y`, `z`, `twist`, `swing`\r\n    axes: {type: 'array', default: []},\r\n\r\n    // How stiff the drive should be\r\n    stiffness: {default: 1.0},\r\n\r\n    // Damping to apply to the drive\r\n    damping: {default: 1.0},\r\n\r\n    // Maximum amount of force used to get to the target position\r\n    forceLimit: {default: 3.4028234663852885981170418348452e+38},\r\n\r\n    // If true, will operate directly on body acceleration rather than on force\r\n    useAcceleration: {default: true},\r\n\r\n    // Target linear velocity relative to the joint\r\n    linearVelocity: {type: 'vec3', default: {x: 0, y: 0, z: 0}},\r\n\r\n    // Targget angular velocity relative to the joint\r\n    angularVelocity: {type: 'vec3', default: {x: 0, y: 0, z: 0}},\r\n\r\n    // If true, will automatically lock axes which are not being driven\r\n    lockOtherAxes: {default: false},\r\n\r\n    // If true SLERP rotation mode. If false, will use SWING mode.\r\n    slerpRotation: {default: true},\r\n  },\r\n  events: {\r\n    'physx-jointcreated': function(e) {\r\n      this.setJointDriver()\r\n    }\r\n  },\r\n  init() {\r\n    this.el.setAttribute('phsyx-custom-constraint', \"\")\r\n  },\r\n  setJointDriver() {\r\n    if (!this.enumAxes) this.update();\r\n    if (this.el.components['physx-joint'].data.type !== 'D6') {\r\n      console.warn(\"Only D6 joint drivers supported at the moment\")\r\n      return;\r\n    }\r\n\r\n    let PhysX = this.el.sceneEl.systems.physx.PhysX;\r\n    this.joint = this.el.components['physx-joint'].joint\r\n\r\n    if (this.data.lockOtherAxes)\r\n    {\r\n      this.joint.setMotion(PhysX.PxD6Axis.eX, PhysX.PxD6Motion.eLOCKED)\r\n      this.joint.setMotion(PhysX.PxD6Axis.eY, PhysX.PxD6Motion.eLOCKED)\r\n      this.joint.setMotion(PhysX.PxD6Axis.eZ, PhysX.PxD6Motion.eLOCKED)\r\n      this.joint.setMotion(PhysX.PxD6Axis.eSWING1, PhysX.PxD6Motion.eLOCKED)\r\n      this.joint.setMotion(PhysX.PxD6Axis.eSWING2, PhysX.PxD6Motion.eLOCKED)\r\n      this.joint.setMotion(PhysX.PxD6Axis.eTWIST, PhysX.PxD6Motion.eLOCKED)\r\n    }\r\n\r\n    for (let enumKey of this.enumAxes)\r\n    {\r\n      this.joint.setMotion(enumKey, PhysX.PxD6Motion.eFREE)\r\n    }\r\n\r\n    let drive = new PhysX.PxD6JointDrive;\r\n    drive.stiffness = this.data.stiffness;\r\n    drive.damping = this.data.damping;\r\n    drive.forceLimit = this.data.forceLimit;\r\n    drive.setAccelerationFlag(this.data.useAcceleration);\r\n\r\n    for (let axis of this.driveAxes)\r\n    {\r\n      this.joint.setDrive(axis, drive);\r\n    }\r\n\r\n    console.log(\"Setting joint driver\", this.driveAxes, this.enumAxes)\r\n\r\n    this.joint.setDrivePosition({translation: {x: 0, y: 0, z: 0}, rotation: {w: 1, x: 0, y: 0, z: 0}}, true)\r\n\r\n    this.joint.setDriveVelocity(this.data.linearVelocity, this.data.angularVelocity, true);\r\n  },\r\n  update(oldData) {\r\n    if (!PhysX) return;\r\n\r\n    this.enumAxes = []\r\n    for (let axis of this.data.axes)\r\n    {\r\n      if (axis === 'swing') {\r\n        this.enumAxes.push(PhysX.PxD6Axis.eSWING1)\r\n        this.enumAxes.push(PhysX.PxD6Axis.eSWING2)\r\n        continue\r\n      }\r\n      let enumKey = `e${axis.toUpperCase()}`\r\n      if (!(enumKey in PhysX.PxD6Axis))\r\n      {\r\n        console.warn(`Unknown axis ${axis} (PxD6Axis::${enumKey})`)\r\n      }\r\n      this.enumAxes.push(PhysX.PxD6Axis[enumKey])\r\n    }\r\n\r\n    this.driveAxes = []\r\n\r\n    for (let axis of this.data.axes)\r\n    {\r\n      if (axis === 'swing') {\r\n        if (this.data.slerpRotation)\r\n        {\r\n          this.driveAxes.push(PhysX.PxD6Drive.eSLERP)\r\n        }\r\n        else\r\n        {\r\n          this.driveAxes.push(PhysX.PxD6Drive.eSWING)\r\n        }\r\n        continue\r\n      }\r\n\r\n      if (axis === 'twist' && this.data.slerpRotation) {\r\n        this.driveAxes.push(PhysX.PxD6Drive.eSLERP)\r\n        continue;\r\n      }\r\n\r\n      let enumKey = `e${axis.toUpperCase()}`\r\n      if (!(enumKey in PhysX.PxD6Drive))\r\n      {\r\n        console.warn(`Unknown axis ${axis} (PxD6Axis::${enumKey})`)\r\n      }\r\n      this.driveAxes.push(PhysX.PxD6Drive[enumKey])\r\n    }\r\n  }\r\n})\r\n\r\n// Adds a constraint to a [`physx-joint`](#physx-joint). Currently only **D6**\r\n// joints are supported.\r\n//\r\n// Can only be used on an entity with the `physx-joint` component. You can set\r\n// multiple constraints per joint. Note that in order to specify attributes of\r\n// individual axes, you will need to use multiple constraints. For instance:\r\n//\r\n//```\r\n// <a-box physx-body>\r\n//   <a-entity physx-joint=\"type: D6\"\r\n//             physx-joint-constraint__xz=\"constrainedAxes: x,z; linearLimit: -1 20\"\r\n//             physx-joint-constraint__y=\"constrainedAxes: y; linearLimit: 0 3; stiffness: 3\"\r\n//             physx-joint-constraint__rotation=\"lockedAxes: twist; swing\"></a-entity>\r\n// </a-box>\r\n//```\r\n//\r\n// In the above example, the box will be able to move from -1 to 20 in both the\r\n// x and z direction. It will be able to move from 0 to 3 in the y direction,\r\n// but this will be a soft constraint, subject to spring forces if the box goes\r\n// past in the y direction. All rotation will be locked. (Note that since no\r\n// target is specified, it will use the scene default target, effectively\r\n// jointed to joint's initial position in the world)\r\nAFRAME.registerComponent('physx-joint-constraint', {\r\n  multiple: true,\r\n  schema: {\r\n    // Which axes are explicitly locked by this constraint and can't be moved at all.\r\n    // Should be some combination of `x`, `y`, `z`, `twist`, `swing`\r\n    lockedAxes: {type: 'array', default: []},\r\n\r\n    // Which axes are constrained by this constraint. These axes can be moved within the set limits.\r\n    // Should be some combination of `x`, `y`, `z`, `twist`, `swing`\r\n    constrainedAxes: {type: 'array', default: []},\r\n\r\n    // Which axes are explicitly freed by this constraint. These axes will not obey any limits set here.\r\n    // Should be some combination of `x`, `y`, `z`, `twist`, `swing`\r\n    freeAxes: {type: 'array', default: []},\r\n\r\n    // Limit on linear movement. Only affects `x`, `y`, and `z` axes.\r\n    // First vector component is the minimum allowed position\r\n    linearLimit: {type: 'vec2'},\r\n\r\n    // Two angles specifying a cone in which the joint is allowed to swing, like\r\n    // a pendulum.\r\n    limitCone: {type: 'vec2'},\r\n\r\n    // Minimum and maximum angles that the joint is allowed to twist\r\n    twistLimit: {type: 'vec2'},\r\n\r\n    // Spring damping for soft constraints\r\n    damping: {default: 0.0},\r\n    // Spring restitution for soft constraints\r\n    restitution: {default: 0.0},\r\n    // If greater than 0, will make this joint a soft constraint, and use a\r\n    // spring force model\r\n    stiffness: {default: 0.0},\r\n  },\r\n  events: {\r\n    'physx-jointcreated': function(e) {\r\n      this.setJointConstraint()\r\n    }\r\n  },\r\n  init() {\r\n    this.el.setAttribute('phsyx-custom-constraint', \"\")\r\n  },\r\n  setJointConstraint() {\r\n    if (this.el.components['physx-joint'].data.type !== 'D6') {\r\n      console.warn(\"Only D6 joint constraints supported at the moment\")\r\n      return;\r\n    }\r\n\r\n    if (!this.constrainedAxes) this.update();\r\n\r\n    let joint = this.el.components['physx-joint'].joint;\r\n\r\n    let llimit = () => {\r\n      let l = new PhysX.PxJointLinearLimitPair(new PhysX.PxTolerancesScale(), this.data.linearLimit.x, this.data.linearLimit.y);\r\n      l.siffness = this.data.stiffness;\r\n      l.damping = this.data.damping;\r\n      l.restitution = this.data.restitution;\r\n      return l\r\n    }\r\n\r\n    for (let axis of this.freeAxes)\r\n    {\r\n      joint.setMotion(axis, PhysX.PxD6Motion.eFREE)\r\n    }\r\n\r\n    for (let axis of this.lockedAxes)\r\n    {\r\n      joint.setMotion(axis, PhysX.PxD6Motion.eLOCKED)\r\n    }\r\n\r\n    for (let axis of this.constrainedAxes)\r\n    {\r\n      if (axis === PhysX.PxD6Axis.eX || axis === PhysX.PxD6Axis.eY || axis === PhysX.PxD6Axis.eZ)\r\n      {\r\n        joint.setMotion(axis, PhysX.PxD6Motion.eLIMITED)\r\n        joint.setLinearLimit(axis, llimit())\r\n        continue;\r\n      }\r\n\r\n      if (axis === PhysX.eTWIST)\r\n      {\r\n        joint.setMotion(PhysX.PxD6Axis.eTWIST, PhysX.PxD6Motion.eLIMITED)\r\n        let pair = new PhysX.PxJointAngularLimitPair(this.data.limitTwist.x, this.data.limitTwist.y)\r\n        pair.stiffness = this.data.stiffness\r\n        pair.damping = this.data.damping\r\n        pair.restitution = this.data.restitution\r\n        joint.setTwistLimit(pair)\r\n        continue;\r\n      }\r\n\r\n      joint.setMotion(axis, PhysX.PxD6Motion.eLIMITED)\r\n      let cone = new PhysX.PxJointLimitCone(this.data.limitCone.x, this.data.limitCone.y)\r\n      cone.damping = this.data.damping\r\n      cone.stiffness = this.data.stiffness\r\n      cone.restitution = this.data.restitution\r\n      joint.setSwingLimit(cone)\r\n    }\r\n  },\r\n  update(oldData) {\r\n    if (!PhysX) return;\r\n\r\n    this.constrainedAxes = PhysXUtil.axisArrayToEnums(this.data.constrainedAxes)\r\n    this.lockedAxes = PhysXUtil.axisArrayToEnums(this.data.lockedAxes)\r\n    this.freeAxes = PhysXUtil.axisArrayToEnums(this.data.freeAxes)\r\n  }\r\n})\r\n\r\n// Creates a PhysX joint between an ancestor rigid body and a target rigid body.\r\n//\r\n// The physx-joint is designed to be used either on or within an entity with the\r\n// `physx-body` component. For instance:\r\n//\r\n// ```\r\n// <a-entity physx-body=\"type: dynamic\">\r\n//   <a-entity physx-joint=\"target: #other-body\" position=\"1 0 0\"></a-entity>\r\n// </a-entity>\r\n// ```\r\n//\r\n// The position and rotation of the `physx-joint` will be used to create the\r\n// corresponding PhysX joint object. Multiple joints can be created on a body,\r\n// and multiple joints can target a body.\r\n//\r\n// **Stapler Example**\r\n//\r\n// Here's a simplified version of the stapler from the [physics playground demo]()\r\n//\r\n//```\r\n// <a-entity id=\"stapler\">\r\n//   <a-entity id=\"stapler-top\" physx-body=\"type: dynamic\" class=\"grab-root\">\r\n//     <a-entity class=\"clickable\" propogate-grab=\"\" gltf-part-plus=\"src: #asset-stapler; part: Top\"></a-entity>\r\n//     <a-entity physx-joint=\"target: #stapler-bottom; type: Revolute; collideWithTarget: true\" position=\"0 0.0254418 -3.7280\"></a-entity>\r\n//   </a-entity>\r\n//   <a-entity id=\"stapler-bottom\" gltf-part-plus=\"src: #asset-stapler; part: Bottom\" physx-body=\"type: dynamic\"></a-entity>\r\n// </a-entity>\r\n//```\r\n//\r\n// Notice the joint is created between the top part of the stapler (which\r\n// contains the joint) and the bottom part of the stapler at the position of the\r\n// `physx-joint` component's entitiy. This will be the pivot point for the\r\n// stapler's rotation.\r\n//\r\n// ![Stapler with joint highlighted](./static/images/staplerjoint.png)\r\nAFRAME.registerComponent('physx-joint', {\r\n  multiple: true,\r\n  schema: {\r\n    // Rigid body joint type to use. See the [NVIDIA PhysX joint\r\n    // documentation](https://gameworksdocs.nvidia.com/PhysX/4.0/documentation/PhysXGuide/Manual/Joints.html)\r\n    // for details on each type\r\n    type: {default: \"Spherical\", oneOf: [\"Fixed\", \"Spherical\", \"Distance\", \"Revolute\", \"Prismatic\", \"D6\"]},\r\n\r\n    // Target object. If specified, must be an entity having the `physx-body`\r\n    // component. If no target is specified, a scene default target will be\r\n    // used, essentially joining the joint to its initial position in the world.\r\n    target: {type: 'selector'},\r\n\r\n    // Force needed to break the constraint. First component is the linear force, second component is angular force. Set both components are >= 0\r\n    breakForce: {type: 'vec2', default: {x: -1, y: -1}},\r\n\r\n    // If true, removes the entity containing this component when the joint is\r\n    // broken.\r\n    removeElOnBreak: {default: false},\r\n\r\n    // If false, collision will be disabled between the rigid body containing\r\n    // the joint and the target rigid body.\r\n    collideWithTarget: {default: false},\r\n\r\n    // When used with a D6 type, sets up a \"soft\" fixed joint. E.g., for grabbing things\r\n    softFixed: {default: false},\r\n  },\r\n  events: {\r\n    constraintbreak: function(e) {\r\n      if (this.data.removeElOnBreak) {\r\n        this.el.remove()\r\n      }\r\n    }\r\n  },\r\n  init() {\r\n    this.system = this.el.sceneEl.systems.physx\r\n\r\n    let parentEl = this.el\r\n\r\n    while (parentEl && !parentEl.hasAttribute('physx-body'))\r\n    {\r\n        parentEl = parentEl.parentEl\r\n    }\r\n\r\n    if (!parentEl) {\r\n      console.warn(\"physx-joint must be used within a physx-body\")\r\n      return;\r\n    }\r\n\r\n    this.bodyEl = parentEl\r\n\r\n    this.worldHelper = new THREE.Object3D;\r\n    this.worldHelperParent = new THREE.Object3D;\r\n    this.el.sceneEl.object3D.add(this.worldHelperParent);\r\n    this.targetScale = new THREE.Vector3(1,1,1)\r\n    this.worldHelperParent.add(this.worldHelper)\r\n\r\n    if (!this.data.target) {\r\n      this.data.target = this.system.defaultTarget\r\n    }\r\n\r\n\r\n    Util.whenLoaded([this.el, this.bodyEl, this.data.target], () => {\r\n      this.createJoint()\r\n    })\r\n  },\r\n  remove() {\r\n    if (this.joint) {\r\n      this.joint.release();\r\n      this.joint = null;\r\n      this.bodyEl.components['physx-body'].rigidBody.wakeUp()\r\n      if (this.data.target.components['physx-body'].rigidBody.wakeUp) this.data.target.components['physx-body'].rigidBody.wakeUp()\r\n    }\r\n  },\r\n  update() {\r\n    if (!this.joint) return;\r\n\r\n    if (this.data.breakForce.x >= 0 && this.data.breakForce.y >= 0)\r\n    {\r\n        this.joint.setBreakForce(this.data.breakForce.x, this.data.breakForce.y);\r\n    }\r\n\r\n    this.joint.setConstraintFlag(PhysX.PxConstraintFlag.eCOLLISION_ENABLED, this.data.collideWithTarget)\r\n\r\n    if (this.el.hasAttribute('phsyx-custom-constraint')) return;\r\n\r\n    switch (this.data.type)\r\n    {\r\n      case 'D6':\r\n      {\r\n        if (this.data.softFixed)\r\n        {\r\n          this.joint.setMotion(PhysX.PxD6Axis.eX, PhysX.PxD6Motion.eFREE)\r\n          this.joint.setMotion(PhysX.PxD6Axis.eY, PhysX.PxD6Motion.eFREE)\r\n          this.joint.setMotion(PhysX.PxD6Axis.eZ, PhysX.PxD6Motion.eFREE)\r\n          this.joint.setMotion(PhysX.PxD6Axis.eSWING1, PhysX.PxD6Motion.eFREE)\r\n          this.joint.setMotion(PhysX.PxD6Axis.eSWING2, PhysX.PxD6Motion.eFREE)\r\n          this.joint.setMotion(PhysX.PxD6Axis.eTWIST, PhysX.PxD6Motion.eFREE)\r\n\r\n          let drive = new PhysX.PxD6JointDrive;\r\n          drive.stiffness = 1000;\r\n          drive.damping = 500;\r\n          drive.forceLimit = 1000;\r\n          drive.setAccelerationFlag(false);\r\n          this.joint.setDrive(PhysX.PxD6Drive.eX, drive);\r\n          this.joint.setDrive(PhysX.PxD6Drive.eY, drive);\r\n          this.joint.setDrive(PhysX.PxD6Drive.eZ, drive);\r\n          // this.joint.setDrive(PhysX.PxD6Drive.eSWING, drive);\r\n          // this.joint.setDrive(PhysX.PxD6Drive.eTWIST, drive);\r\n          this.joint.setDrive(PhysX.PxD6Drive.eSLERP, drive);\r\n          this.joint.setDrivePosition({translation: {x: 0, y: 0, z: 0}, rotation: {w: 1, x: 0, y: 0, z: 0}}, true)\r\n          this.joint.setDriveVelocity({x: 0.0, y: 0.0, z: 0.0}, {x: 0, y: 0, z: 0}, true);\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  },\r\n  getTransform(el) {\r\n    Util.positionObject3DAtTarget(this.worldHelperParent, el.object3D, {scale: this.targetScale})\r\n\r\n    Util.positionObject3DAtTarget(this.worldHelper, this.el.object3D, {scale: this.targetScale});\r\n\r\n    let transform = PhysXUtil.matrixToTransform(this.worldHelper.matrix);\r\n\r\n    return transform;\r\n  },\r\n  async createJoint() {\r\n    await Util.whenComponentInitialized(this.bodyEl, 'physx-body')\r\n    await Util.whenComponentInitialized(this.data.target, 'physx-body')\r\n    await this.bodyEl.components['physx-body'].physxRegisteredPromise;\r\n    await this.data.target.components['physx-body'].physxRegisteredPromise;\r\n\r\n    if (this.joint) {\r\n      this.joint.release();\r\n      this.joint = null;\r\n    }\r\n\r\n    let thisTransform = this.getTransform(this.bodyEl);\r\n    let targetTransform = this.getTransform(this.data.target);\r\n\r\n    this.joint = PhysX[`Px${this.data.type}JointCreate`](this.system.physics,\r\n                                                         this.bodyEl.components['physx-body'].rigidBody, thisTransform,\r\n                                                         this.data.target.components['physx-body'].rigidBody, targetTransform,\r\n                                                        )\r\n    this.system.registerJoint(this.joint, this)\r\n    this.update();\r\n    this.el.emit('physx-jointcreated', this.joint)\r\n  }\r\n})\r\n\r\n\r\nAFRAME.registerSystem('physx-contact-event', {\r\n  init() {\r\n    this.worldHelper = new THREE.Object3D;\r\n    this.el.sceneEl.object3D.add(this.worldHelper)\r\n  }\r\n})\r\n\r\n// Emits a `contactevent` event when a collision meets the threshold.  This\r\n// should be set on an entity with the `physx-body` component. The event detail\r\n// will contain these fields:\r\n// - `impulse`: The summed impulse of at all contact points\r\n// - `contact`: The originating contact event\r\nAFRAME.registerComponent('physx-contact-event', {\r\n  dependencies: ['physx-body'],\r\n  schema: {\r\n  // Minimum total impulse threshold to emit the event\r\n  impulseThreshold: {default: 0.01},\r\n\r\n  // NYI\r\n  maxDistance: {default: 10.0},\r\n  // NYI\r\n  maxDuration: {default: 5.0},\r\n\r\n  // Delay after start of scene before emitting events. Useful to avoid a\r\n  // zillion events as objects initially settle on the ground\r\n  startDelay: {default: 6000},\r\n\r\n  // If `true`, the event detail will include a `positionWorld` property which contains the weighted averaged location\r\n  // of all contact points. Contact points are weighted by impulse amplitude.\r\n  positionAtContact: {default: false},\r\n  },\r\n  events: {\r\n    contactbegin: function(e) {\r\n      if (this.el.sceneEl.time < this.data.startDelay) return\r\n      let thisWorld = this.eventDetail.positionWorld;\r\n      let cameraWorld = this.pool('cameraWorld', THREE.Vector3);\r\n\r\n      let impulses = e.detail.impulses\r\n      let impulseSum = 0\r\n      for (let i = 0; i < impulses.size(); ++i)\r\n      {\r\n        impulseSum += impulses.get(i)\r\n      }\r\n\r\n      if (impulseSum < this.data.impulseThreshold) return;\r\n\r\n      thisWorld.set(0, 0, 0)\r\n      let impulse = 0.0;\r\n      if (this.data.positionAtContact)\r\n      {\r\n        for (let i = 0; i < impulses.size(); ++i)\r\n        {\r\n          impulse = impulses.get(i);\r\n          let position = e.detail.points.get(i);\r\n          thisWorld.x += position.x * impulse;\r\n          thisWorld.y += position.y * impulse;\r\n          thisWorld.z += position.z * impulse;\r\n        }\r\n        thisWorld.multiplyScalar(1.0 / impulseSum)\r\n        this.system.worldHelper.position.copy(thisWorld)\r\n        Util.positionObject3DAtTarget(this.localHelper, this.system.worldHelper)\r\n        this.eventDetail.position.copy(this.localHelper.position)\r\n      }\r\n      else\r\n      {\r\n        thisWorld.set(0, 0, 0)\r\n        this.eventDetail.position.set(0, 0, 0)\r\n      }\r\n\r\n      this.eventDetail.impulse = impulseSum\r\n      this.eventDetail.contact = e.detail\r\n\r\n      this.el.emit('contactevent', this.eventDetail)\r\n    }\r\n  },\r\n  init() {\r\n    VARTISTE.Pool.init(this)\r\n\r\n    this.eventDetail = {\r\n      impulse: 0.0,\r\n      positionWorld: new THREE.Vector3(),\r\n      position: new THREE.Vector3(),\r\n      contact: null,\r\n    }\r\n\r\n    if (this.data.debug) {\r\n      let vis = document.createElement('a-entity')\r\n      vis.setAttribute('geometry', 'primitive: sphere; radius: 0.1')\r\n      vis.setAttribute('physx-no-collision', '')\r\n    }\r\n\r\n    this.localHelper = new THREE.Object3D();\r\n    this.el.object3D.add(this.localHelper)\r\n\r\n    this.el.setAttribute('physx-body', 'emitCollisionEvents', true)\r\n  },\r\n  remove() {\r\n    this.el.object3D.remove(this.localHelper)\r\n  }\r\n})\r\n\r\n// Plays a sound when a `physx-body` has a collision.\r\nAFRAME.registerComponent('physx-contact-sound', {\r\n  dependencies: ['physx-contact-event'],\r\n  schema: {\r\n    // Sound file location or asset\r\n    src: {type: 'string'},\r\n\r\n    // Minimum total impulse to play the sound\r\n    impulseThreshold: {default: 0.01},\r\n\r\n    // NYI\r\n    maxDistance: {default: 10.0},\r\n    // NYI\r\n    maxDuration: {default: 5.0},\r\n\r\n    // Delay after start of scene before playing sounds. Useful to avoid a\r\n    // zillion sounds playing as objects initially settle on the ground\r\n    startDelay: {default: 6000},\r\n\r\n    // If `true`, the sound will be positioned at the weighted averaged location\r\n    // of all contact points. Contact points are weighted by impulse amplitude.\r\n    // If `false`, the sound will be positioned at the entity's origin.\r\n    positionAtContact: {default: false},\r\n  },\r\n  events: {\r\n    contactevent: function(e) {\r\n      if (this.data.positionAtContact)\r\n      {\r\n        this.sound.object3D.position.copy(e.detail.position)\r\n      }\r\n\r\n      this.sound.components.sound.stopSound();\r\n      this.sound.components.sound.playSound();\r\n    },\r\n  },\r\n  init() {\r\n    let sound = document.createElement('a-entity')\r\n    this.el.append(sound)\r\n    sound.setAttribute('sound', {src: this.data.src})\r\n    this.sound = sound\r\n\r\n    this.el.setAttribute('physx-body', 'emitCollisionEvents', true)\r\n  },\r\n  update(oldData) {\r\n    this.el.setAttribute('physx-contact-event', this.data)\r\n  }\r\n})\r\n\r\n// Creates A-Frame entities from gltf custom properties.\r\n//\r\n// **WARNING** do not use this component with untrusted gltf models, since it\r\n// will let the model access arbitrary components.\r\n//\r\n// Should be set on an entity with the `gltf-model` component. Once the model is\r\n// loaded, this will traverse the object tree, and any objects containing user\r\n// data key `a-entity` will be turned into separate sub-entities. The user data\r\n// value for `a-entity` will be set as the attributes.\r\n//\r\n// For instance, say you export a model with the following kind of structure\r\n// from Blender (remembering to check \"Include → Custom Properties\"!):\r\n//\r\n//```\r\n//    - Empty1\r\n//      Custom Properties:\r\n//        name: a-entity\r\n//        value: physx-body=\"type: dynamic\"\r\n//      Children:\r\n//        - Mesh1\r\n//          Custom Properties:\r\n//             name: a-entity\r\n//             value: physx-material=\"density: 30\" class=\"clickable\"\r\n//          Children:\r\n//            - Mesh2\r\n//        - Mesh3\r\n//           Custom Properties:\r\n//             name: a-entity\r\n//             value: physx-material=\"density: 100\" physx-contact-sound=\"src: #boom\"\r\n//```\r\n//\r\n// ![Screenshot showing the structure in Blender](./static/images/blenderentities.png)\r\n//\r\n// This will turn into the following HTML (with `setId` set to `true`):\r\n//\r\n//```\r\n// <a-entity id=\"Empty1\" physx-body=\"type: dynamic\"> <!-- getObject3D('mesh') returns Empty1 with no children -->\r\n//    <a-entity id=\"Mesh1\" physx-material=\"density: 30\" class=\"clickable\"></a-entity> <!-- getObject3D('mesh') returns Mesh1 with Mesh2 as a child-->\r\n//    <a-entity id=\"Mesh3\" physx-material=\"density: 100\" physx-contact-sound=\"src: #boom\"></a-entity> <!-- getObject3D('mesh') returns Mesh3 with no child-->\r\n// </a-entity>\r\n//```\r\n//\r\n// **Experimental Blender Plugin**\r\n//\r\n// ![Screenshot showing experimental blender plugin](./static/images/blenderplugin.png)\r\n//\r\n// I've written a small plugin for [Blender](https://www.blender.org/) which can\r\n// automatically set up a lot of the common properties for use in this physics\r\n// system. _Note that it is super experimental and under development. Make a\r\n// backup before using._\r\n//\r\n// **Download Blender Plugin:** <a id=\"blender-plugin-link\">vartiste_toolkit_entity_helper.zip (v0.2.0)</a>\r\n//\r\n// **GLB Viewer**\r\n//\r\n// You can test your `gltf-entities` enabled glb files locally by dragging and\r\n// dropping them into this [web viewer](https://fascinated-hip-period.glitch.me/viewer.html)\r\nAFRAME.registerComponent('gltf-entities', {\r\n  dependencies: ['gltf-model'],\r\n  schema: {\r\n    // If true, will set created element's id based on the gltf object name\r\n    setId: {default: false},\r\n    // If `setId` is true, this will be prepended to the gltf object name when setting the element id\r\n    idPrefix: {default: \"\"},\r\n\r\n    // Automatically make entities clickable and propogate the grab (for use with [`manipulator`](#manipulator))\r\n    autoPropogateGrab: {default: true},\r\n\r\n    // Array of attribute names that should be copied from this entitiy to any new created entitity\r\n    copyAttributes: {type: 'array'},\r\n\r\n    // A list of names of attributes that are allowed to be set. Ignored if empty.\r\n    allowedAttributes: {type: 'array'},\r\n  },\r\n  events: {\r\n    'model-loaded': function(e) {\r\n      this.setupEntities()\r\n    }\r\n  },\r\n  init() {},\r\n  setupEntities() {\r\n    let root = this.el.getObject3D('mesh')\r\n    if (!root) return;\r\n\r\n    this.setupObject(root, this.el)\r\n  },\r\n  setupObject(obj3d, currentRootEl)\r\n  {\r\n    if (obj3d.userData['a-entity']) {\r\n      let el = document.createElement('a-entity')\r\n      let attrs = obj3d.userData['a-entity']\r\n\r\n      // sanitize\r\n      el.innerHTML = attrs\r\n      el.innerHTML = `<a-entity ${el.innerText}></a-entity>`\r\n\r\n      el = el.children[0]\r\n\r\n      if (this.data.allowedAttributes.length)\r\n      {\r\n        for (let attr of el.attributes)\r\n        {\r\n          if (!this.data.allowedAttributes.includes(attr.name))\r\n          {\r\n            el.removeAttribute(attr.name)\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this.data.setId && obj3d.name)\r\n      {\r\n        el.id = `${this.data.idPrefix}${obj3d.name}`\r\n      }\r\n\r\n      for (let attribute of this.data.copyAttributes)\r\n      {\r\n        if (this.el.hasAttribute(attribute))\r\n        {\r\n          el.setAttribute(attribute, this.el.getAttribute(attribute))\r\n        }\r\n      }\r\n\r\n      if (this.data.autoPropogateGrab && this.el.classList.contains(\"clickable\"))\r\n      {\r\n        el.setAttribute('propogate-grab', \"\")\r\n        el.classList.add(\"clickable\")\r\n      }\r\n\r\n      currentRootEl.append(el)\r\n      Util.whenLoaded(el, () => {\r\n        el.setObject3D('mesh', obj3d)\r\n        obj3d.updateMatrix()\r\n        Util.applyMatrix(obj3d.matrix, el.object3D)\r\n        obj3d.matrix.identity()\r\n        Util.applyMatrix(obj3d.matrix, obj3d)\r\n      })\r\n      currentRootEl = el\r\n    }\r\n\r\n    for (let child of obj3d.children)\r\n    {\r\n      this.setupObject(child, currentRootEl)\r\n    }\r\n  }\r\n})\r\n\n\n//# sourceURL=webpack://@c-frame/physx/./src/physics.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;